// Advanced Library Service
// Handles versioning, collaboration, smart suggestions, and advanced features

export interface NoteVersion {
  id: string;
  noteId: string;
  versionNumber: number;
  content: string;
  contentData: any;
  metadata: any;
  changeSummary?: string;
  changeType: 'create' | 'edit' | 'delete' | 'restore';
  isAutoSave: boolean;
  createdAt: string;
  createdBy: string;
}

export interface Collaboration {
  id: string;
  noteId: string;
  ownerId: string;
  sharedWithId: string;
  permissionLevel: 'read' | 'comment' | 'edit';
  status: 'active' | 'revoked' | 'expired';
  expiresAt?: string;
  createdAt: string;
  updatedAt: string;
}

export interface Comment {
  id: string;
  noteId: string;
  collaborationId?: string;
  authorId: string;
  content: string;
  positionData: any;
  isResolved: boolean;
  parentCommentId?: string;
  createdAt: string;
  updatedAt: string;
}

export interface NoteLink {
  id: string;
  sourceNoteId: string;
  targetNoteId: string;
  linkType: 'reference' | 'citation' | 'trades' | 'pattern';
  contextData: any;
  createdAt: string;
}

export interface SmartTag {
  id: string;
  noteId: string;
  tagName: string;
  tagType: 'auto' | 'user' | 'ai';
  confidenceScore: number;
  autoGenerated: boolean;
  createdAt: string;
}

export interface Suggestion {
  id: string;
  noteId?: string;
  userId: string;
  suggestionType: 'content' | 'template' | 'tag' | 'reference' | 'completion';
  suggestionData: any;
  contextData: any;
  status: 'pending' | 'applied' | 'dismissed';
  confidenceScore: number;
  createdAt: string;
  appliedAt?: string;
}

export interface Reminder {
  id: string;
  noteId: string;
  userId: string;
  reminderType: 'deadline' | 'followup' | 'review' | 'action';
  reminderDate: string;
  message: string;
  isCompleted: boolean;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  repeatPattern?: string;
  createdAt: string;
  completedAt?: string;
}

export interface VoiceNote {
  id: string;
  noteId: string;
  userId: string;
  audioUrl?: string;
  transcript?: string;
  durationSeconds?: number;
  languageCode: string;
  transcriptionStatus: 'pending' | 'processing' | 'completed' | 'failed';
  confidenceScore?: number;
  createdAt: string;
}

export interface ExportJob {
  id: string;
  noteId?: string;
  userId: string;
  exportType: 'pdf' | 'docx' | 'md' | 'html' | 'json';
  exportSettings: any;
  fileUrl?: string;
  fileName?: string;
  fileSizeBytes?: number;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  createdAt: string;
  completedAt?: string;
}

class AdvancedLibraryService {
  private storagePrefix = 'tradejournal_advanced_';

  // Version Management
  async createVersion(
    noteId: string,
    userId: string,
    content: string,
    contentData?: any,
    metadata?: any,
    changeSummary?: string,
    changeType: 'create' | 'edit' | 'delete' | 'restore' = 'edit'
  ): Promise<NoteVersion> {
    const versions = this.getStorageItem('note_versions', []);
    const noteVersions = versions.filter((v: any) => v.noteId === noteId);
    const versionNumber = noteVersions.length + 1;

    const version: NoteVersion = {
      id: this.generateId(),
      noteId,
      versionNumber,
      content,
      contentData: contentData || {},
      metadata: metadata || {},
      changeSummary,
      changeType,
      isAutoSave: false,
      createdAt: new Date().toISOString(),
      createdBy: userId
    };

    versions.push(version);
    this.setStorageItem('note_versions', versions);
    return version;
  }

  async getNoteVersions(noteId: string): Promise<NoteVersion[]> {
    const versions = this.getStorageItem('note_versions', []);
    return versions.filter((v: any) => v.noteId === noteId)
      .sort((a: any, b: any) => b.versionNumber - a.versionNumber);
  }

  async restoreVersion(noteId: string, versionId: string): Promise<any> {
    const versions = this.getStorageItem('note_versions', []);
    const version = versions.find((v: any) => v.id === versionId && v.noteId === noteId);
    
    if (version) {
      // Create a new version for the restore action
      await this.createVersion(
        noteId,
        version.createdBy,
        version.content,
        version.contentData,
        version.metadata,
        `Restored to version ${version.versionNumber}`,
        'restore'
      );
      
      return {
        content: version.content,
        contentData: version.contentData,
        metadata: version.metadata
      };
    }
    throw new Error('Version not found');
  }

  // Collaboration
  async createCollaboration(
    noteId: string,
    ownerId: string,
    sharedWithId: string,
    permissionLevel: 'read' | 'comment' | 'edit' = 'read'
  ): Promise<Collaboration> {
    const collaborations = this.getStorageItem('collaborations', []);
    
    const collaboration: Collaboration = {
      id: this.generateId(),
      noteId,
      ownerId,
      sharedWithId,
      permissionLevel,
      status: 'active',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    collaborations.push(collaboration);
    this.setStorageItem('collaborations', collaborations);
    return collaboration;
  }

  async getNoteCollaborations(noteId: string): Promise<Collaboration[]> {
    const collaborations = this.getStorageItem('collaborations', []);
    return collaborations.filter((c: any) => c.noteId === noteId && c.status === 'active');
  }

  async revokeCollaboration(collaborationId: string): Promise<void> {
    const collaborations = this.getStorageItem('collaborations', []);
    const collaboration = collaborations.find((c: any) => c.id === collaborationId);
    
    if (collaboration) {
      collaboration.status = 'revoked';
      collaboration.updatedAt = new Date().toISOString();
      this.setStorageItem('collaborations', collaborations);
    }
  }

  // Comments
  async createComment(
    noteId: string,
    authorId: string,
    content: string,
    positionData?: any,
    collaborationId?: string,
    parentCommentId?: string
  ): Promise<Comment> {
    const comments = this.getStorageItem('comments', []);
    
    const comment: Comment = {
      id: this.generateId(),
      noteId,
      authorId,
      content,
      positionData: positionData || {},
      isResolved: false,
      collaborationId,
      parentCommentId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    comments.push(comment);
    this.setStorageItem('comments', comments);
    return comment;
  }

  async getNoteComments(noteId: string): Promise<Comment[]> {
    const comments = this.getStorageItem('comments', []);
    return comments.filter((c: any) => c.noteId === noteId)
      .sort((a: any, b: any) => a.createdAt.localeCompare(b.createdAt));
  }

  async resolveComment(commentId: string): Promise<void> {
    const comments = this.getStorageItem('comments', []);
    const comment = comments.find((c: any) => c.id === commentId);
    
    if (comment) {
      comment.isResolved = true;
      comment.updatedAt = new Date().toISOString();
      this.setStorageItem('comments', comments);
    }
  }

  // Note Links
  async createLink(
    sourceNoteId: string,
    targetNoteId: string,
    linkType: 'reference' | 'citation' | 'trades' | 'pattern' = 'reference',
    contextData?: any
  ): Promise<NoteLink> {
    const links = this.getStorageItem('note_links', []);
    
    // Check if link already exists
    const existing = links.find((l: any) => 
      l.sourceNoteId === sourceNoteId && 
      l.targetNoteId === targetNoteId && 
      l.linkType === linkType
    );

    if (existing) {
      return existing;
    }

    const link: NoteLink = {
      id: this.generateId(),
      sourceNoteId,
      targetNoteId,
      linkType,
      contextData: contextData || {},
      createdAt: new Date().toISOString()
    };

    links.push(link);
    this.setStorageItem('note_links', links);
    return link;
  }

  async getNoteLinks(noteId: string): Promise<NoteLink[]> {
    const links = this.getStorageItem('note_links', []);
    return links.filter((l: any) => 
      l.sourceNoteId === noteId || l.targetNoteId === noteId
    );
  }

  // Smart Tags
  async generateSmartTags(content: string, existingTags: string[] = []): Promise<SmartTag[]> {
    const tags: SmartTag[] = [];
    const lowercaseContent = content.toLowerCase();
    
    // Trading-related keywords
    const tradingKeywords = [
      { keyword: 'trade', tag: 'trading', confidence: 0.9 },
      { keyword: 'analysis', tag: 'analysis', confidence: 0.8 },
      { keyword: 'strategy', tag: 'strategy', confidence: 0.9 },
      { keyword: 'psychology', tag: 'psychology', confidence: 0.8 },
      { keyword: 'emotion', tag: 'emotions', confidence: 0.7 },
      { keyword: 'risk', tag: 'risk-management', confidence: 0.8 },
      { keyword: 'profit', tag: 'profit', confidence: 0.7 },
      { keyword: 'loss', tag: 'losses', confidence: 0.7 },
      { keyword: 'entry', tag: 'entry', confidence: 0.8 },
      { keyword: 'exit', tag: 'exit', confidence: 0.8 },
      { keyword: 'stop', tag: 'stop-loss', confidence: 0.9 },
      { keyword: 'target', tag: 'targets', confidence: 0.8 },
      { keyword: 'pivot', tag: 'pivot-points', confidence: 0.9 },
      { keyword: 'support', tag: 'support-resistance', confidence: 0.8 },
      { keyword: 'resistance', tag: 'support-resistance', confidence: 0.8 },
      { keyword: 'trend', tag: 'trend-analysis', confidence: 0.8 },
      { keyword: 'breakout', tag: 'breakout', confidence: 0.9 },
      { keyword: 'reversal', tag: 'reversals', confidence: 0.8 },
      { keyword: 'volume', tag: 'volume', confidence: 0.7 },
      { keyword: 'momentum', tag: 'momentum', confidence: 0.8 }
    ];

    for (const { keyword, tag, confidence } of tradingKeywords) {
      if (lowercaseContent.includes(keyword) && !existingTags.includes(tag)) {
        tags.push({
          id: this.generateId(),
          noteId: '', // Will be set when saving
          tagName: tag,
          tagType: 'auto',
          confidenceScore: confidence,
          autoGenerated: true,
          createdAt: new Date().toISOString()
        });
      }
    }

    return tags;
  }

  async saveSmartTags(noteId: string, tags: SmartTag[]): Promise<SmartTag[]> {
    const savedTags = this.getStorageItem('smart_tags', []);
    
    tags.forEach(tag => {
      tag.noteId = noteId;
      savedTags.push(tag);
    });
    
    this.setStorageItem('smart_tags', savedTags);
    return tags;
  }

  // Suggestions
  async generateSuggestions(
    content: string,
    userId: string,
    noteId?: string
  ): Promise<Suggestion[]> {
    const suggestions: Suggestion[] = [];
    const lowercaseContent = content.toLowerCase();

    // Template suggestions
    if (lowercaseContent.includes('analysis') && !lowercaseContent.includes('template')) {
      suggestions.push({
        id: this.generateId(),
        noteId,
        userId,
        suggestionType: 'template',
        suggestionData: {
          title: 'Analysis Template',
          description: 'Use Market Analysis template for better structure',
          templateId: 'market-analysis'
        },
        contextData: { trigger: 'analysis_keyword' },
        status: 'pending',
        confidenceScore: 0.8,
        createdAt: new Date().toISOString()
      });
    }

    // Tag suggestions
    const tagSuggestions = await this.generateSmartTags(content);
    if (tagSuggestions.length > 0) {
      suggestions.push({
        id: this.generateId(),
        noteId,
        userId,
        suggestionType: 'tag',
        suggestionData: {
          suggestedTags: tagSuggestions.map(t => t.tagName)
        },
        contextData: { confidence: Math.max(...tagSuggestions.map(t => t.confidenceScore)) },
        status: 'pending',
        confidenceScore: 0.7,
        createdAt: new Date().toISOString()
      });
    }

    // Reference suggestions
    if (lowercaseContent.includes('similar') || lowercaseContent.includes('like')) {
      suggestions.push({
        id: this.generateId(),
        noteId,
        userId,
        suggestionType: 'reference',
        suggestionData: {
          type: 'related_notes',
          description: 'Look for similar notes or patterns'
        },
        contextData: { trigger: 'similarity_search' },
        status: 'pending',
        confidenceScore: 0.6,
        createdAt: new Date().toISOString()
      });
    }

    // Auto-complete suggestions
    const tradingTerms = [
      'risk management', 'position sizing', 'stop loss', 'take profit',
      'entry signal', 'exit strategy', 'market analysis', 'technical analysis'
    ];

    for (const term of tradingTerms) {
      if (lowercaseContent.includes(term.split(' ')[0]) && 
          !lowercaseContent.includes(term)) {
        suggestions.push({
          id: this.generateId(),
          noteId,
          userId,
          suggestionType: 'completion',
          suggestionData: {
            term: term,
            description: `Consider adding: ${term}`
          },
          contextData: { partial: term.split(' ')[0] },
          status: 'pending',
          confidenceScore: 0.5,
          createdAt: new Date().toISOString()
        });
        break; // Only suggest one completion at a time
      }
    }

    return suggestions;
  }

  // Reminders
  async createReminder(
    noteId: string,
    userId: string,
    message: string,
    reminderDate: string,
    reminderType: 'deadline' | 'followup' | 'review' | 'action' = 'followup',
    priority: 'low' | 'medium' | 'high' | 'urgent' = 'medium'
  ): Promise<Reminder> {
    const reminders = this.getStorageItem('reminders', []);
    
    const reminder: Reminder = {
      id: this.generateId(),
      noteId,
      userId,
      reminderType,
      reminderDate,
      message,
      isCompleted: false,
      priority,
      createdAt: new Date().toISOString()
    };

    reminders.push(reminder);
    this.setStorageItem('reminders', reminders);
    return reminder;
  }

  async getReminders(userId: string, upcoming: boolean = true): Promise<Reminder[]> {
    const reminders = this.getStorageItem('reminders', []);
    const now = new Date();
    
    return reminders
      .filter((r: any) => r.userId === userId)
      .filter((r: any) => !upcoming || new Date(r.reminderDate) > now)
      .sort((a: any, b: any) => a.reminderDate.localeCompare(b.reminderDate));
  }

  async completeReminder(reminderId: string): Promise<void> {
    const reminders = this.getStorageItem('reminders', []);
    const reminder = reminders.find((r: any) => r.id === reminderId);
    
    if (reminder) {
      reminder.isCompleted = true;
      reminder.completedAt = new Date().toISOString();
      this.setStorageItem('reminders', reminders);
    }
  }

  // Voice Notes
  async saveVoiceNote(
    noteId: string,
    userId: string,
    audioBlob: Blob,
    transcript?: string
  ): Promise<VoiceNote> {
    const voiceNotes = this.getStorageItem('voice_notes', []);
    
    // In a real implementation, you would upload the audio file to storage
    const audioUrl = URL.createObjectURL(audioBlob);
    
    const voiceNote: VoiceNote = {
      id: this.generateId(),
      noteId,
      userId,
      audioUrl,
      transcript,
      durationSeconds: undefined, // Would be calculated from audio
      languageCode: 'en-US',
      transcriptionStatus: transcript ? 'completed' : 'pending',
      confidenceScore: transcript ? 0.8 : undefined,
      createdAt: new Date().toISOString()
    };

    voiceNotes.push(voiceNote);
    this.setStorageItem('voice_notes', voiceNotes);
    return voiceNote;
  }

  // Export
  async createExportJob(
    noteId: string | undefined,
    userId: string,
    exportType: 'pdf' | 'docx' | 'md' | 'html' | 'json',
    exportSettings: any = {}
  ): Promise<ExportJob> {
    const exportJobs = this.getStorageItem('export_jobs', []);
    
    const job: ExportJob = {
      id: this.generateId(),
      noteId,
      userId,
      exportType,
      exportSettings,
      status: 'processing',
      createdAt: new Date().toISOString()
    };

    exportJobs.push(job);
    this.setStorageItem('export_jobs', exportJobs);
    
    // Simulate processing
    setTimeout(() => {
      this.completeExportJob(job.id, 'completed');
    }, 2000);
    
    return job;
  }

  private completeExportJob(jobId: string, status: 'completed' | 'failed'): void {
    const exportJobs = this.getStorageItem('export_jobs', []);
    const job = exportJobs.find((j: any) => j.id === jobId);
    
    if (job) {
      job.status = status;
      job.completedAt = new Date().toISOString();
      if (status === 'completed') {
        job.fileName = `export_${job.exportType}_${Date.now()}.${job.exportType}`;
        job.fileUrl = URL.createObjectURL(new Blob([''])); // Mock URL
        job.fileSizeBytes = Math.floor(Math.random() * 1000000) + 50000; // Mock size
      }
      this.setStorageItem('export_jobs', exportJobs);
    }
  }

  // Utility methods
  private getStorageItem(key: string, defaultValue: any): any {
    try {
      const item = localStorage.getItem(this.storagePrefix + key);
      return item ? JSON.parse(item) : defaultValue;
    } catch {
      return defaultValue;
    }
  }

  private setStorageItem(key: string, value: any): void {
    try {
      localStorage.setItem(this.storagePrefix + key, JSON.stringify(value));
    } catch (error) {
      console.error('Failed to save to localStorage:', error);
    }
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
}

export const advancedLibraryService = new AdvancedLibraryService();
